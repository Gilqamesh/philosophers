#include <pthread.h>
Compile and link with -pthread

Difference from processes:
	- threads share the same memory space, while processes gets a copy
		from the parent process.
	- threads are running in parallel in the same process ID, while
		each process have their own process ID. 

Functions:
pthread_create:	int	pthread_create(pthread_t *restrict thread,
                    	 	const pthread_attr_t *restrict attr,
                         	void *(*start_routine)(void *),
                          	void *restrict arg);
	- starts a new thread in the calling process.
	- the new thread starts execution by invoking start_routine().
	- 'arg' is passed as the sole argument of start_routine().

	The new thread terminates in one of the following ways:
	- it calls pthread_exit(), specifying an exit status value that is available
		to another thread in the same process that calls pthread_join().
	- it returns from start_routine().
	- it is canceled (see pthread_cancel()).
	- any of the threads in the process calls exit(), or the main thread
		performs a return from main(). This causes the termination of all
		threads in the process.

	The 'attr' argument points to a pthread_attr_t structure whose contents are
	used at thread creation time to determine attributes for the new thread;
	this structure is initialized during pthread_attr_init() and related
	functions. If 'attr' is NULL, then the thread is created with the default
	attributes.

	Before returning, a successful call to pthread_create() stores the ID of the
	new thread in the buffer pointed to by 'thread'; this identifier is used to
	refer to the thread in the subsequent calls to other pthreads functions.

	The new thread inherits a copy of the creating thread's signal mask
	(pthread_sigmask()). The set of pending signals for the new thread is empty
	(sigpending()). The new thread does not inherit the creating thread's
	alternate signal stack (sigaltstack()).

	The new thread inherits the calling thread's floating-point environment (fenv()).

	The initial value of the new thread's CPU-time clock is 0 (pthread_getcpuclockid()).

	Return value: On success, pthread_create() returns 0; on error, it returns
		an error number, and the contents of *thread are undefined.

	Errors:
		EAGAIN: Insufficient resources to create another thread.
		EAGAIN: A system-imposed limit on the number of threads was encountered.
			There are a number of limits that may trigger this error, RTFM.
		EINVAL: Invalid settings in 'attr'.
		EPERM: No permission to set the scheduling policy and parameters
			specified in 'attr'.

pthread_join:	int	pthread_join(pthread_t thread,
									void **retval);
	- The pthread_join() function waits for the thread specified by 'thread'
		to terminate. If that thread has already terminated, then pthread_join()
		returns immediately. The thread specified by 'thread' must be joinable.
	- If 'retval' is not NULL, then pthread_join() copies the exit status of the
		target thread (i.e., the value that the target thread supplied to
		pthread_exit()) into the location pointed to by 'retval'. If the target
		thread was canceled, then PTHREAD_CANCELED is placed in the location
		pointed to by 'retval'.
	- If multiple threads simultaneously try to join with the same thread, the
		results are undefied. If the thread calling pthread_join() is cancelled,
		then the target thread will remain joinable (i.e., it will not be detached).

	Return value: On success, pthread_join() returns 0; on error, it returns an
		error number.

	Errors:
		EDEADLK: A deadlock was detected (e.g., two threads tried to join with
			each other); or 'thread' specifies the calling thread.
		EINVAL: 'thread' is not a joinable thread.
		EINVAL: Another thread is already waiting to join with this thread.
		ESRCH: No thread with the ID 'thread' could be found.

(only with multi-core processors, with single-core processor its very unlikely)
Race condition: happens when multiple thread is trying to access the same memory
	location. The data can become corrupt, so we have to guarantee this does not
	happen.
	Example can be seen in 'race_condition.c', each increment of the variable
		is actually 3 steps:
			- read from memory
			- increment var
			- write to memory
		It could happen that the two threads are interfering with each other
		and by the time one thread finished this loop a few times, the other
		is still in 'read' state, in which case it'll write an already incremented
		value back to memory, losing previous progress.
	To solve this issue we can use the idea of mutexes.

Idea of mutexes: use pthread_mutex_lock() and pthread_mutex_unlock() as brackets
	at parts of a code that we want to protect. The thread that locks that mutex
	will execute the code and only after it unlocks the mutex can only other
	threads also run that code -> no interfering with the same memory space in
	parallel threadding.

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

pthread_mutex_destroy, pthread_mutex_init:
					int	pthread_mutex_init(pthread_mutex_t *restrict mutex,
           							const pthread_mutexattr_t *restrict attr);
					int pthread_mutex_destroy(pthread_mutex_t *mutex);
	- the pthread_mutex_destroy() function shall destroy the mutex object
		referenced by 'mutex'; the mutex object becomes, in effect, uninitialized.
		An implementation may cause pthread_mutex_destroy() to set the object
		referenced to 'muted' to an invalid vallue. A destroyed mutex object
		can be reinitialized using pthread_mutex_init(); the results otherwise
		referencing the object after it has been destroyed are undefined.
	- It shall be safe to destroy an initialized mutex that is unlocked.
		Attempting to destroy a locked mutex results in undefined behavior.
	- The pthread_mutex_init() function shall initialize the mutex referenced
		by 'mutex' with attributes specified by 'attr'. If 'attr' is NULL, the
		default mutex attributes are used; the effect shall be the same as
		passing the address of a default mutex attributes object. Upon successful
		initialization, the state of the mutex becomes initialized and unlocked.
	- Only mutex itself may be used for performing synchronization. The result of
		referring to copies of mutex in calls to pthread_mutex_lock(), pthread_mutex_trylock(),
		pthread_mutex_unlock(), and pthread_mutex_destroy() is undefined.
	- Attempting to initialize an already initialized mutex results in undefined behavior.
	- In cases where default mutex attributes are appropriate, the macro PTHREAD_MUTEX_INITIALIZER
		can be used to initialize mutexes that are statically allocated. The effect shall
		be equivalent to dynamic initialization by a call to pthread_mutex_init() with parameter
		'attr' specified as NULL, except that no error checks are performed.

	Return value: If successful, the pthread_mutex_destroy() and pthread_mutex_init()
		functions shall return zero; otherwise, an error number shall be return to
		indicate the error.

	Errors:
		The pthread_mutex_destroy() function may fail if:
		EBUSY: The implementation has detected an attempt to destroy the object
			referenced by 'mutex' while it is locked or referenced by another thread.
		EINVAL: The value specified by 'mutex' is invalid.

		The pthread_mutex_init() function shall fail if:
		EAGAIN: The system lacked the necessary resources (other than memory) to
			initialize another mutex.
		ENOMEM: Insufficient memory exists to initialize the mutex.
		EPERM: The caller does not have the privilage to perform the operation.

		The pthread_mutex_init() function may fail if:
		EBUSY: The implementation has detected an attempt to reinitialize the object
			referenced by 'mutex', a previously initialized, but not yet destroyed, mutex.
		EINVAL: The value specified by 'attr' is invalid.

pthread_detach: int pthread_detach(pthread_t thread)
	- The pthread_detach() function marks the thread identified by 'thread' as
		detached. When a detached thread terminates, its resources are automatically
		released back to the system without the need for another thread to join
		with the terminated thread.
	- Attempting to detach an already detached thread results in unspecified bahavior.

	Return value: On success, pthread_detach() returns 0; on error, it returns an
		error number.

	Errors:
		EINVAL: 'thread' is not a joinable thread.
		ESRCH: No thread with the ID 'thread' could be found.

Concepts:
	- Race condition: Described above
	- Deadlock: There are multiple mutexes and threads and there is a situation
		in which all thread is waiting for a mutex that they do not own
		themselves. This leads to a state where each thread is just waiting for
		the mutexes forever.
	- Semaphore: acts kind of similarly to mutexes
		- first initialize the semaphore to some value X
		- there are two functions, call them semaphore_wait and semaphore_post
		- whenever a thread hits a semaphore_wait, it checks for the semaphore's
			value:
				- if it's 0, it waits until it isn't.
				- if it's greater than 0, it decrements it and executes the code
					after it.
			whenever the semaphore_post call is reached, it increments the
			semaphore by 1.
		- use case is kind of similar to mutexes if we have initialized the
			semaphore with a value of 1.
			- Difference is that mutex has a concept of ownership to them associated,
				as to say, if one thread locks and the other thread unlocks the same
				mutex, we will have undefinied behavior if the other thread is unlocking the
				same mutex multiple times.
		Practical use  of a semaphore: Login Queue